---
source: tests/emitter_test.rs
expression: "emitter::Emitter::new().emit(parsed).unwrap()"
---
EmitterResult {
    files: [
        Dir {
            name: "src",
            files: [
                File {
                    name: "main.cpp",
                    content: "#include <stdlib.h>\n#include <stdio.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <memory>\n#include \"runtime.hpp\"\nint main() {\nTsFunction* _main = new TsFunction(\"main\",TsCoreHelpers::toVector<TsFunctionParam>({}), [=](TsObject* _this, std::vector<TsFunctionArg> args) -> TsObject* {\nconsole->getFieldValue(\"log\")->invoke(TsCoreHelpers::toVector<TsFunctionArg>({TsFunctionArg(\"sdjkl\", new TsString(\"hello, world!\"))}));\nreturn NULL;\n});\n_main->invoke(TsCoreHelpers::toVector<TsFunctionArg>({}));\n}",
                },
                File {
                    name: "runtime.cpp",
                    content: "#include <stdlib.h>\r\n#include <stdio.h>\r\n#include <string>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <memory>\r\n#include <stdexcept>\r\n#include <typeinfo>\r\n\r\n#include \"runtime.hpp\"\r\n\r\nTsObject::TsObject(int typeId, std::vector<TsObjectField *> fields)\r\n\t: typeId(typeId),\r\n\t  fields(fields)\r\n{\r\n\tfor (auto field : fields)\r\n\t{\r\n\t\tauto value = field->value;\r\n\r\n\t\t// For any functions that don't have an explicit `this` set, use this object as `this`.\r\n\t\tif (value->typeId == TypeIdTsFunction)\r\n\t\t{\r\n\t\t\tTsFunction *fn = dynamic_cast<TsFunction *>(value);\r\n\t\t\tif (fn->thisFn == NULL)\r\n\t\t\t{\r\n\t\t\t\tfn->thisFn = [this]() -> TsObject * { return this; };\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nTsObjectField *TsObject::getField(const std::string &field_name) const\r\n{\r\n\treturn *std::find_if(this->fields.begin(), this->fields.end(), [field_name](TsObjectField *field)\r\n\t\t\t\t\t\t { return field->descriptor.name == field_name; });\r\n}\r\n\r\nTsObjectFieldDescriptor TsObject::getFieldDescriptor(const std::string &field_name) const\r\n{\r\n\treturn getField(field_name)->descriptor;\r\n}\r\n\r\nTsObject *TsObject::getFieldValue(const std::string &fieldName) const\r\n{\r\n\treturn getField(fieldName)->value;\r\n}\r\n\r\nvoid TsObject::setFieldValue(const std::string &field_name, TsObject *value)\r\n{\r\n\tauto field = getField(field_name);\r\n\r\n\t// If there's no existing field, create one.\r\n\tif (field == NULL)\r\n\t{\r\n\t\t// Create a new field.\r\n\t\tauto new_field = new TsObjectField(TsObjectFieldDescriptor(field_name, value->typeId), value);\r\n\r\n\t\t// Attach the field.\r\n\t\tthis->fields.push_back(new_field);\r\n\r\n\t\treturn;\r\n\t}\r\n\r\n\t// Otherwise, just set the field.\r\n\t// TODO: handle freeing memory (whoops!).\r\n\tfield->value = value;\r\n}\r\n\r\ntemplate <typename T>\r\nvoid TsObject::addIntrinsicField(const std::string &fieldName, T value)\r\n{\r\n\tauto descriptor = TsObjectFieldDescriptor(TsString(fieldName), TypeIdIntrinsic);\r\n\tauto object = new IntrinsicTsObject<T>(value);\r\n\tauto field = new TsObjectField(descriptor, object);\r\n\r\n\tthis->fields.push_back(field);\r\n}\r\n\r\ntemplate <typename T>\r\nT TsObject::getIntrinsicField(const std::string &fieldName) const\r\n{\r\n\tauto field = dynamic_cast<IntrinsicTsObject<T> *>(this->getFieldValue(fieldName));\r\n\r\n\treturn field->value;\r\n}\r\n\r\nTsObject *TsObject::invoke(std::vector<TsFunctionArg> args)\r\n{\r\n\tthrow std::runtime_error(\"type is not invocable!\");\r\n}\r\n\r\nconst TsFunctionArg &TsFunctionArg::findArg(const std::vector<TsFunctionArg> &args, const std::string &argName)\r\n{\r\n\treturn *std::find_if(args.begin(), args.end(), [argName](auto arg)\r\n\t\t\t\t\t\t { return arg.name == argName; });\r\n}\r\n\r\nTsObject *TsFunction::invoke(std::vector<TsFunctionArg> args)\r\n{\r\n\t// If there's no thisFn, use ourself.\r\n\tauto _this = this->thisFn == NULL ? this : this->thisFn();\r\n\r\n\treturn fn(_this, args);\r\n}\r\n\r\nTsObject *console = new TsObject(TypeIdTsObject, TsCoreHelpers::toVector<TsObjectField *>({new TsObjectField(\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t TsObjectFieldDescriptor(TsString(\"log\"), TypeIdTsFunction),\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t new TsFunction(\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t \"log\",\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t TsCoreHelpers::toVector<TsFunctionParam>({}),\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t [](auto _this, auto args) -> TsObject *\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t auto fmt = dynamic_cast<TsString *>(args[0].value);\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t printf(\"%s\\n\", fmt->value.c_str());\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t return NULL;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t }))}));\r\n",
                },
                File {
                    name: "runtime.hpp",
                    content: "#pragma once\r\n\r\n#include <stdlib.h>\r\n#include <stdio.h>\r\n#include <string>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <memory>\r\n#include <functional>\r\n\r\n// TODO: don't do this.\r\n#define UNDEFINED 0xDEADBEEF\r\n\r\ntemplate <typename T>\r\nclass IntrinsicTsObject;\r\n\r\nclass TsString;\r\nclass TsFunctionParam;\r\nclass TsFunctionArg;\r\nclass TsFunction;\r\nclass TsObjectFieldDescriptor;\r\nclass TsObjectField;\r\n\r\nclass TsCoreHelpers\r\n{\r\npublic:\r\n    template <class T>\r\n    static std::vector<T> toVector(std::initializer_list<T> args)\r\n    {\r\n        auto result = std::vector<T>();\r\n        for (auto arg : args)\r\n        {\r\n            result.push_back(arg);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    template <typename T>\r\n    static std::vector<T> toVector()\r\n    {\r\n        return std::vector<T>();\r\n    }\r\n};\r\n\r\nenum TypeId\r\n{\r\n    TypeIdNone = 0,\r\n    TypeIdTsObject = 1,\r\n    TypeIdTsNum = 2,\r\n    TypeIdTsString = 3,\r\n    TypeIdTsFunction = 4,\r\n    TypeIdVoid = 5,\r\n    TypeIdIntrinsic = 6,\r\n};\r\n\r\nclass TsObject\r\n{\r\npublic:\r\n    int typeId;\r\n    std::vector<TsObjectField *> fields;\r\n\r\n    TsObject(int typeId)\r\n        : TsObject(typeId, std::vector<TsObjectField *>()) {}\r\n\r\n    TsObject(int typeId, std::vector<TsObjectField *> fields);\r\n\r\n    TsObjectField *getField(const std::string &field_name) const;\r\n\r\n    TsObjectFieldDescriptor getFieldDescriptor(const std::string &field_name) const;\r\n\r\n    TsObject *getFieldValue(const std::string &fieldName) const;\r\n\r\n    void setFieldValue(const std::string &field_name, TsObject *value);\r\n\r\n    template <typename T>\r\n    void addIntrinsicField(const std::string &fieldName, T value);\r\n\r\n    template <typename T>\r\n    T getIntrinsicField(const std::string &fieldName) const;\r\n\r\n    virtual TsObject *invoke(std::vector<TsFunctionArg> args);\r\n};\r\n\r\ntemplate <typename T>\r\nclass IntrinsicTsObject : public TsObject\r\n{\r\npublic:\r\n    T value;\r\n\r\n    IntrinsicTsObject(T value)\r\n        : value(value),\r\n          TsObject(TypeIdIntrinsic) {}\r\n\r\n    bool operator==(const IntrinsicTsObject<T> &other) const\r\n    {\r\n        return value == other.value;\r\n    }\r\n};\r\n\r\nclass TsNum : public TsObject\r\n{\r\npublic:\r\n    int num;\r\n\r\n    TsNum(int num)\r\n        : num(num),\r\n          TsObject(TypeIdTsNum) {}\r\n\r\n    bool operator==(const TsNum &other) const\r\n    {\r\n        return num == other.num;\r\n    }\r\n};\r\n\r\nclass TsString : public TsObject\r\n{\r\npublic:\r\n    std::string value;\r\n\r\n    TsString(std::string value)\r\n        : value(value),\r\n          TsObject(TypeIdTsString) {}\r\n\r\n    bool operator==(const TsString &other) const\r\n    {\r\n        return value == other.value;\r\n    }\r\n\r\n    bool operator==(const std::string &other) const\r\n    {\r\n        return value == other;\r\n    }\r\n};\r\n\r\nclass TsFunctionParam\r\n{\r\npublic:\r\n    std::string name;\r\n    int type_id;\r\n\r\n    TsFunctionParam(std::string name, int type_id)\r\n        : name(name),\r\n          type_id(type_id) {}\r\n};\r\n\r\nclass TsFunctionArg\r\n{\r\npublic:\r\n    std::string name;\r\n    TsObject *value;\r\n\r\n    TsFunctionArg(std::string name, TsObject *value)\r\n        : name(name),\r\n          value(value) {}\r\n\r\n    static const TsFunctionArg &findArg(const std::vector<TsFunctionArg> &args, const std::string &argName);\r\n};\r\n\r\nclass TsFunction : public TsObject\r\n{\r\npublic:\r\n    std::string name;\r\n    std::vector<TsFunctionParam> params;\r\n    std::function<TsObject *()> thisFn;\r\n\r\n    std::function<TsObject *(TsObject *, std::vector<TsFunctionArg> args)> fn;\r\n\r\n    TsFunction(\r\n        std::string name,\r\n        std::vector<TsFunctionParam> params,\r\n        std::function<TsObject *(TsObject *, std::vector<TsFunctionArg> args)> fn)\r\n        : name(name),\r\n          params(params),\r\n          fn(fn),\r\n          TsObject(TypeIdTsFunction) {}\r\n\r\n    virtual TsObject *invoke(std::vector<TsFunctionArg> args) override;\r\n};\r\n\r\nclass TsObjectFieldDescriptor\r\n{\r\npublic:\r\n    TsString name;\r\n    int typeId;\r\n\r\n    TsObjectFieldDescriptor(TsString name, int typeId)\r\n        : name(name),\r\n          typeId(typeId) {}\r\n};\r\n\r\nclass TsObjectField\r\n{\r\npublic:\r\n    TsObjectFieldDescriptor descriptor;\r\n    TsObject *value;\r\n\r\n    TsObjectField(TsObjectFieldDescriptor descriptor)\r\n        : TsObjectField(descriptor, NULL) {}\r\n\r\n    TsObjectField(TsObjectFieldDescriptor descriptor, TsObject *value)\r\n        : descriptor(descriptor),\r\n          value(value) {}\r\n};\r\n\r\nextern TsObject *console;\r\n",
                },
            ],
        },
    ],
}
