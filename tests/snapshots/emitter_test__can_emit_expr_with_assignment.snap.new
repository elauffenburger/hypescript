---
source: tests/emitter_test.rs
assertion_line: 204
expression: "emitter::Emitter::new().emit(&parsed).unwrap()"
---
EmitterResult {
    files: [
        Dir {
            name: "src",
            files: [
                File {
                    name: "main.cpp",
                    content: "#include <stdlib.h>\n#include <stdio.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <memory>\n#include \"runtime.hpp\"\nint main() {\nauto _foo = new TsObject(1, {new TsObjectField(TsObjectFieldDescriptor(\"name\", 0), new TsString(\"i'm a bar!\"))});\n_foo->setFieldValue(\"name\", new TsString(\"i'm a foo!\"));\n}",
                },
                File {
                    name: "runtime.cpp",
                    content: "#include <algorithm>\r\n#include <math.h>\r\n#include <memory>\r\n#include <stdexcept>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string>\r\n#include <typeinfo>\r\n#include <vector>\r\n\r\n#include \"runtime.hpp\"\r\n\r\n// TsNum\r\n\r\nTsNum::TsNum(float value) : value(value), TsObject(TypeIdTsNum) {\r\n  this->fields.push_back(new TsObjectField(\r\n      TsObjectFieldDescriptor(\"++\", 0),\r\n      new TsFunction(\r\n          \"++\", {},\r\n          [=](TsObject *_this, std::vector<TsFunctionArg> args) -> TsObject * {\r\n            this->value++;\r\n\r\n            return _this;\r\n          })));\r\n\r\n  this->fields.push_back(new TsObjectField(\r\n      TsObjectFieldDescriptor(\"<\", 0),\r\n      new TsFunction(\r\n          \"<\", {TsFunctionParam(\"other\", 0)},\r\n          [=](TsObject *_this, std::vector<TsFunctionArg> args) -> TsObject * {\r\n            auto other = dynamic_cast<TsNum *>(\r\n                TsFunctionArg::findArg(args, \"other\").value);\r\n\r\n            return new TsBool(this->value < other->value);\r\n          })));\r\n\r\n  this->fields.push_back(new TsObjectField(\r\n      TsObjectFieldDescriptor(\"+\", 0),\r\n      new TsFunction(\r\n          \"+\", {TsFunctionParam(\"other\", 0)},\r\n          [=](TsObject *_this, std::vector<TsFunctionArg> args) -> TsObject * {\r\n            auto other = dynamic_cast<TsNum *>(\r\n                TsFunctionArg::findArg(args, \"other\").value);\r\n\r\n            return new TsNum(this->value + other->value);\r\n          })));\r\n\r\n  this->fields.push_back(new TsObjectField(\r\n      TsObjectFieldDescriptor(\"%\", 0),\r\n      new TsFunction(\r\n          \"%\", {TsFunctionParam(\"other\", 0)},\r\n          [=](TsObject *_this, std::vector<TsFunctionArg> args) -> TsObject * {\r\n            auto other = dynamic_cast<TsNum *>(\r\n                TsFunctionArg::findArg(args, \"other\").value);\r\n\r\n            return new TsNum(fmod(this->value, other->value));\r\n          })));\r\n\r\n  this->fields.push_back(new TsObjectField(\r\n      TsObjectFieldDescriptor(\"==\", 0),\r\n      new TsFunction(\r\n          \"==\", {TsFunctionParam(\"other\", 0)},\r\n          [=](TsObject *_this, std::vector<TsFunctionArg> args) -> TsObject * {\r\n            auto other = TsFunctionArg::findArg(args, \"other\").value;\r\n\r\n            switch (other->typeId) {\r\n            case TypeIdTsNum:\r\n              return new TsBool(this->value ==\r\n                                dynamic_cast<TsNum *>(other)->value);\r\n            }\r\n          })));\r\n}\r\n\r\n// TsBool\r\n\r\nTsBool::TsBool(bool value) : value(value), TsObject(TypeIdBool) {\r\n  this->fields.push_back(new TsObjectField(\r\n      TsObjectFieldDescriptor(\"&&\", 0),\r\n      new TsFunction(\r\n          \"&&\", {TsFunctionParam(\"other\", 0)},\r\n          [=](TsObject *_this, std::vector<TsFunctionArg> args) -> TsObject * {\r\n            auto other = dynamic_cast<TsBool *>(\r\n                TsFunctionArg::findArg(args, \"other\").value);\r\n\r\n            return new TsBool(this->value && other->value);\r\n          })));\r\n}\r\n\r\n// TsFunction\r\n\r\nTsFunctionParam::TsFunctionParam(std::string name, int type_id)\r\n    : name(name), type_id(type_id) {}\r\n\r\nTsFunctionArg::TsFunctionArg(std::string name, TsObject *value)\r\n    : name(name), value(value) {}\r\n\r\nconst TsFunctionArg &\r\nTsFunctionArg::findArg(const std::vector<TsFunctionArg> &args,\r\n                       const std::string &argName) {\r\n  return *std::find_if(args.begin(), args.end(),\r\n                       [argName](auto arg) { return arg.name == argName; });\r\n}\r\n\r\nTsFunction::TsFunction(\r\n    std::string name, std::vector<TsFunctionParam> params,\r\n    std::function<TsObject *(TsObject *, std::vector<TsFunctionArg> args)> fn)\r\n    : name(name), params(params), fn(fn), TsObject(TypeIdTsFunction) {}\r\n\r\nTsObjectFieldDescriptor::TsObjectFieldDescriptor(std::string name, int typeId)\r\n    : name(name), typeId(typeId) {}\r\n\r\n// TsObject\r\n\r\nTsObject::TsObject(int typeId, std::vector<TsObjectField *> fields)\r\n    : typeId(typeId), fields(fields) {\r\n  for (auto field : fields) {\r\n    auto value = field->value;\r\n\r\n    // For any functions that don't have an explicit `this` set, use this object\r\n    // as `this`.\r\n    if (value->typeId == TypeIdTsFunction) {\r\n      TsFunction *fn = dynamic_cast<TsFunction *>(value);\r\n      if (fn->thisFn == NULL) {\r\n        fn->thisFn = [this]() -> TsObject * { return this; };\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nTsObjectField::TsObjectField(TsObjectFieldDescriptor descriptor)\r\n    : TsObjectField(descriptor, NULL) {}\r\n\r\nTsObjectField::TsObjectField(TsObjectFieldDescriptor descriptor,\r\n                             TsObject *value)\r\n    : descriptor(descriptor), value(value) {}\r\n\r\nTsObjectField *TsObject::getField(const std::string &field_name) const {\r\n  return *std::find_if(this->fields.begin(), this->fields.end(),\r\n                       [field_name](TsObjectField *field) {\r\n                         return field->descriptor.name == field_name;\r\n                       });\r\n}\r\n\r\nTsObjectFieldDescriptor\r\nTsObject::getFieldDescriptor(const std::string &field_name) const {\r\n  return getField(field_name)->descriptor;\r\n}\r\n\r\nTsObject *TsObject::getFieldValue(const std::string &fieldName) const {\r\n  return getField(fieldName)->value;\r\n}\r\n\r\nvoid TsObject::setFieldValue(const std::string &field_name, TsObject *value) {\r\n  auto field = getField(field_name);\r\n\r\n  // If there's no existing field, create one.\r\n  if (field == NULL) {\r\n    // Create a new field.\r\n    auto new_field = new TsObjectField(\r\n        TsObjectFieldDescriptor(field_name, value->typeId), value);\r\n\r\n    // Attach the field.\r\n    this->fields.push_back(new_field);\r\n\r\n    return;\r\n  }\r\n\r\n  // Otherwise, just set the field.\r\n  // TODO: handle freeing memory (whoops!).\r\n  field->value = value;\r\n}\r\n\r\ntemplate <typename T>\r\nvoid TsObject::addIntrinsicField(const std::string &fieldName, T value) {\r\n  auto descriptor = TsObjectFieldDescriptor(fieldName, TypeIdIntrinsic);\r\n  auto object = new IntrinsicTsObject<T>(value);\r\n  auto field = new TsObjectField(descriptor, object);\r\n\r\n  this->fields.push_back(field);\r\n}\r\n\r\ntemplate <typename T>\r\nT TsObject::getIntrinsicField(const std::string &fieldName) const {\r\n  auto field =\r\n      dynamic_cast<IntrinsicTsObject<T> *>(this->getFieldValue(fieldName));\r\n\r\n  return field->value;\r\n}\r\n\r\nTsObject *TsObject::invoke(std::vector<TsFunctionArg> args) {\r\n  throw std::runtime_error(\"type is not invocable!\");\r\n}\r\n\r\nTsObject *TsFunction::invoke(std::vector<TsFunctionArg> args) {\r\n  // If there's no thisFn, use ourself.\r\n  auto _this = this->thisFn == NULL ? this : this->thisFn();\r\n\r\n  return fn(_this, args);\r\n}\r\n\r\n// Globals\r\n\r\nTsObject *console = new TsObject(\r\n    TypeIdTsObject,\r\n    {new TsObjectField(\r\n        TsObjectFieldDescriptor(\"log\", TypeIdTsFunction),\r\n        new TsFunction(\"log\", {}, [](auto _this, auto args) -> TsObject * {\r\n          auto fmt = args[0].value->toTsString();\r\n\r\n          printf(\"%s\\n\", fmt->value.c_str());\r\n\r\n          return NULL;\r\n        }))});\r\n",
                },
                File {
                    name: "runtime.hpp",
                    content: "#pragma once\r\n\r\n#include <algorithm>\r\n#include <functional>\r\n#include <memory>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string>\r\n#include <vector>\r\n\r\n// TODO: don't do this.\r\n#define UNDEFINED 0xDEADBEEF\r\n\r\ntemplate <typename T> class IntrinsicTsObject;\r\n\r\nclass TsString;\r\nclass TsFunctionParam;\r\nclass TsFunctionArg;\r\nclass TsFunction;\r\nclass TsObjectFieldDescriptor;\r\nclass TsObjectField;\r\n\r\nenum TypeId {\r\n  TypeIdNone = 0,\r\n  TypeIdTsObject = 1,\r\n  TypeIdTsNum = 2,\r\n  TypeIdTsString = 3,\r\n  TypeIdTsFunction = 4,\r\n  TypeIdVoid = 5,\r\n  TypeIdIntrinsic = 6,\r\n  TypeIdBool = 7,\r\n};\r\n\r\nclass TsObject {\r\npublic:\r\n  int typeId;\r\n  std::vector<TsObjectField *> fields;\r\n\r\n  TsObject(int typeId) : TsObject(typeId, std::vector<TsObjectField *>()) {}\r\n\r\n  TsObject(int typeId, std::vector<TsObjectField *> fields);\r\n\r\n  TsObjectField *getField(const std::string &field_name) const;\r\n\r\n  TsObjectFieldDescriptor\r\n  getFieldDescriptor(const std::string &field_name) const;\r\n\r\n  TsObject *getFieldValue(const std::string &fieldName) const;\r\n\r\n  void setFieldValue(const std::string &field_name, TsObject *value);\r\n\r\n  template <typename T>\r\n  void addIntrinsicField(const std::string &fieldName, T value);\r\n\r\n  template <typename T> T getIntrinsicField(const std::string &fieldName) const;\r\n\r\n  virtual TsObject *invoke(std::vector<TsFunctionArg> args);\r\n\r\n  virtual bool truthy() { throw \"not implemented!\"; }\r\n\r\n  virtual TsString *toTsString() { return NULL; }\r\n};\r\n\r\nclass TsString : public TsObject {\r\npublic:\r\n  std::string value;\r\n\r\n  TsString(std::string value) : value(value), TsObject(TypeIdTsString) {}\r\n\r\n  bool operator==(const TsString &other) const { return value == other.value; }\r\n\r\n  bool operator==(const std::string &other) const { return value == other; }\r\n\r\n  virtual bool truthy() override { return value != \"\"; }\r\n\r\n  virtual TsString *toTsString() override { return this; }\r\n};\r\n\r\ntemplate <typename T> class IntrinsicTsObject : public TsObject {\r\npublic:\r\n  T value;\r\n\r\n  IntrinsicTsObject(T value) : value(value), TsObject(TypeIdIntrinsic) {}\r\n\r\n  bool operator==(const IntrinsicTsObject<T> &other) const {\r\n    return value == other.value;\r\n  }\r\n\r\n  virtual TsString *toTsString() override { return new TsString(\"object\"); }\r\n};\r\n\r\nclass TsNum : public TsObject {\r\npublic:\r\n  float value;\r\n\r\n  TsNum(float value);\r\n\r\n  bool operator==(const TsNum &other) const { return value == other.value; }\r\n\r\n  virtual TsString *toTsString() override {\r\n    if (value == (int)value) {\r\n      return new TsString(std::to_string((int)value));\r\n    }\r\n\r\n    return new TsString(std::to_string(value));\r\n  }\r\n\r\n  virtual bool truthy() override { return value != 0; }\r\n};\r\n\r\nclass TsBool : public TsObject {\r\npublic:\r\n  bool value;\r\n\r\n  TsBool(bool value);\r\n\r\n  bool operator==(const TsBool &other) const { return value == other.value; }\r\n\r\n  operator bool() const { return value; }\r\n\r\n  virtual TsString *toTsString() override {\r\n    return new TsString(value ? \"true\" : \"false\");\r\n  }\r\n\r\n  virtual bool truthy() override { return value; }\r\n};\r\n\r\nclass TsFunctionParam {\r\npublic:\r\n  std::string name;\r\n  int type_id;\r\n\r\n  TsFunctionParam(std::string name, int type_id);\r\n};\r\n\r\nclass TsFunctionArg {\r\npublic:\r\n  std::string name;\r\n  TsObject *value;\r\n\r\n  TsFunctionArg(std::string name, TsObject *value);\r\n\r\n  static const TsFunctionArg &findArg(const std::vector<TsFunctionArg> &args,\r\n                                      const std::string &argName);\r\n};\r\n\r\nclass TsFunction : public TsObject {\r\npublic:\r\n  std::string name;\r\n  std::vector<TsFunctionParam> params;\r\n  std::function<TsObject *()> thisFn;\r\n\r\n  std::function<TsObject *(TsObject *, std::vector<TsFunctionArg> args)> fn;\r\n\r\n  TsFunction(\r\n      std::string name, std::vector<TsFunctionParam> params,\r\n      std::function<TsObject *(TsObject *, std::vector<TsFunctionArg> args)>\r\n          fn);\r\n\r\n  virtual TsObject *invoke(std::vector<TsFunctionArg> args) override;\r\n\r\n  virtual TsString *toTsString() override {\r\n    return new TsString(\"function<\" + name + \">\");\r\n  }\r\n\r\n  virtual bool truthy() override { return true; }\r\n};\r\n\r\nclass TsObjectFieldDescriptor {\r\npublic:\r\n  std::string name;\r\n  int typeId;\r\n\r\n  TsObjectFieldDescriptor(std::string name, int typeId);\r\n};\r\n\r\nclass TsObjectField {\r\npublic:\r\n  TsObjectFieldDescriptor descriptor;\r\n  TsObject *value;\r\n\r\n  TsObjectField(TsObjectFieldDescriptor descriptor);\r\n\r\n  TsObjectField(TsObjectFieldDescriptor descriptor, TsObject *value);\r\n};\r\n\r\nextern TsObject *console;\r\n",
                },
            ],
        },
    ],
}
